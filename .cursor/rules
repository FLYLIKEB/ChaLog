## Git Workflow

- Before commit/push: Check `docs/git-strategy.md` (branch naming, merge procedures)
- When modifying screens/routes: Check `docs/architecture.md` and update if needed
- Pre-commit checks: `npm test`, `npm run lint`, `tsc --noEmit`
- Commit messages: Write in Korean (e.g., `feat: 노트 필터 기능 추가`, `fix: 인증 버그 수정`)

## Documentation Updates

When making code changes, automatically update relevant markdown files:

- **README.md**: Update when adding new features, changing project structure, updating dependencies, or modifying setup instructions
- **docs/architecture.md**: Update when modifying routes/pages, component structure, data flow, or architectural patterns
- **docs/git-strategy.md**: Update when changing Git workflow or branch strategy
- **Backend README** (`backend/README.md`): Update when modifying backend structure, API endpoints, or setup

**Update triggers:**
- New features → README.md (주요 기능 섹션), architecture.md (해당 섹션)
- API changes → README.md (데이터 & 외부 연동), architecture.md (API 섹션)
- Component changes → architecture.md (컴포넌트 구조)
- Route/page changes → architecture.md (라우트 섹션), README.md (폴더 구조)
- Dependency changes → README.md (NPM 스크립트, 환경 변수)
- File structure changes → README.md (폴더 구조 하이라이트)
- Backend module changes → backend/README.md, architecture.md

**Update process:**
1. Analyze code changes to identify what documentation needs updating
2. Check relevant markdown files for sections that need updates
3. Update documentation to reflect code changes accurately
4. Ensure documentation examples match current code structure
5. Include code changes in the same commit when possible

## Release Automation

- Full release: `scripts/full-release.sh "<commit-msg>" "<version-tag>" [feature/branch]`
  - Example: `scripts/full-release.sh "feat: add note filters" v0.5.0`
  - Process: test/lint → feature push → main merge+tag

## Utility Scripts

### Git Workflow Scripts

- **Quick commit**: `scripts/quick-commit.sh [branch] [message]`
  - Auto-commit and push changes
  - Example: `scripts/quick-commit.sh feature/new-feature "feat: 새로운 기능 추가"`
  - See `docs/SCRIPTS.md` for details

- **Full release**: `scripts/full-release.sh "<commit-msg>" "<version-tag>" [feature-branch]`
  - Complete release automation (test → merge → tag → deploy)
  - Example: `scripts/full-release.sh "Release v1.2.3" "v1.2.3" feature/new-feature`
  - See `docs/SCRIPTS.md` for details

### Database Management Scripts

- **Start SSH tunnel**: `cd backend && ./scripts/start-ssh-tunnel.sh`
  - Start SSH tunnel for RDS connection via EC2
  - Requires `.env` file with SSH configuration
  - See `docs/DATABASE.md` and `docs/SCRIPTS.md` for details

- **Stop SSH tunnel**: `cd backend && ./scripts/stop-ssh-tunnel.sh`
  - Stop running SSH tunnel

- **Check database**: `cd backend && ./scripts/check-database.sh`
  - Verify database connection and create database if needed
  - Requires SSH tunnel to be running

**Script usage workflow:**
1. Before development: `cd backend && ./scripts/start-ssh-tunnel.sh`
2. Verify connection: `cd backend && ./scripts/check-database.sh`
3. Start backend: `cd backend && npm run start:dev`
4. After development: `cd backend && ./scripts/stop-ssh-tunnel.sh`

For detailed script documentation, see `docs/SCRIPTS.md`

## Quick Commit & Push ("ch" command)

When user types "ch" or "커밋", automatically execute:

1. Branch management: Check current branch → if `main`, create `feature/*` branch based on changes
2. Change analysis: `git status` → group by feature (auth, notes, teas, components, config, etc.)
3. Documentation check: Analyze changes → identify which markdown files need updates (README.md, docs/architecture.md, etc.) → update if needed
4. Feature-based commits: Stage each group → auto-generate Korean commit message (`feat:`, `fix:`, `refactor:`, etc.) → commit
5. Push & summary: After all commits, push → provide branch/commit summary

**Alternative:** Use `scripts/quick-commit.sh` script for manual quick commits:
```bash
./scripts/quick-commit.sh [branch] [message]
```

## Quick Pull ("pl" command)

When user types "pl" or "풀", automatically execute:

1. Remote update: `git fetch --all --prune`
2. Current branch pull: `git pull origin <current-branch>`
3. Main branch pull: Update `main` (checkout → pull → return)
4. Summary: Provide updated branches and changes summary

## Merge Main to All Branches ("merge-main" or "mg" command)

When user types "merge-main" or "mg", automatically execute:

1. Save current branch → update `main` → get all local branches (excluding `main`)
2. For each branch: checkout → `git merge main --no-edit` → skip if conflicts
3. Push all branches to remote: For each successfully merged branch, push to origin (use `--force-with-lease` if diverged)
4. Return to original branch → provide summary

## Clean Remote Branches ("clean" or "cl" command)

When user types "clean" or "cl", automatically execute:

1. Fetch and prune: `git fetch --all --prune`
2. Find gone branches: List local branches that track remote branches that no longer exist
3. Confirm and delete: Show list of branches to delete → delete them (use `git branch -D`)
4. Summary: Provide list of deleted branches

## Pre-commit Validation

Before any commit, automatically execute:

1. Lint check: `npm run lint` (if exists)
2. Type check: `tsc --noEmit` (if TypeScript project)
3. Test run: `npm run test:run` (if exists)
4. If any check fails, prevent commit and show error message
5. Only proceed with commit if all checks pass

**Note:** The `scripts/quick-commit.sh` script includes pre-commit validation automatically.

## Create Pull Request ("pr" or "pr생성" command)

When user types "pr" or "pr생성", automatically execute:

1. Check current branch: Must be a feature branch (`feature/*`)
2. Ensure branch is pushed: Push current branch to origin if not already pushed
3. Generate PR title: Based on branch name and recent commits
4. Generate PR description: Summarize commits, changed files, and affected modules
5. Create PR: Use GitHub CLI (`gh pr create`) or provide manual instructions with URL
6. Summary: Provide PR URL and details

## Code Style & Patterns

### Frontend (React + TypeScript)
- Use functional components with hooks, avoid class components
- Use `cn()` utility from `components/ui/utils.ts` for className merging
- Follow shadcn/ui component patterns: use Radix UI primitives + CVA for variants
- Import paths: Use `@/` alias for `src/` directory (e.g., `@/components/Button`)
- Component structure: Props interface → component → export default
- Use TypeScript strict types, avoid `any` unless necessary
- Prefer named exports for utilities, default exports for components

### Backend (NestJS)
- Use dependency injection with `@Injectable()` decorator
- Follow NestJS module pattern: Controller → Service → Entity
- Use DTOs for request/response validation
- Error handling: Use NestJS built-in exceptions (`NotFoundException`, `ForbiddenException`, etc.)
- Service methods should be async and return Promises
- Use TypeORM repositories with `@InjectRepository()` decorator

### File Structure
- Components: `src/components/` (UI components in `components/ui/`)
- Pages: `src/pages/` (route components)
- Backend modules: `backend/src/{module}/` (controller, service, entities, dto)
- Shared types: `packages/types/` (use in both frontend and backend)
- Utils: `src/lib/` (frontend), `backend/src/common/` (backend)

## Component Guidelines

- UI components: Use shadcn/ui components from `components/ui/` as base
- Custom components: Create in `components/` with descriptive names (PascalCase)
- Props: Define TypeScript interfaces above component
- Styling: Use Tailwind CSS classes, prefer utility classes over custom CSS
- Accessibility: Include proper ARIA labels and keyboard navigation
- Icons: Use `lucide-react` icons, import individually

## Type Definitions

- Shared types: Define in `packages/types/index.ts` for frontend/backend sharing
- Component props: Define inline or in same file
- API types: Match backend DTOs in `packages/types/`
- Use TypeScript utility types (`Pick`, `Omit`, `Partial`) when appropriate

## Testing

- Frontend: Use Vitest + Testing Library, tests in `__tests__/` directories
- Backend: Use Jest, tests alongside source files (`.spec.ts`)
- Test naming: `*.test.tsx` (frontend), `*.spec.ts` (backend)
- Mock data: Use `src/lib/mockData.ts` for frontend tests
- Test structure: Arrange → Act → Assert pattern

## Error Handling

- Frontend: Use try-catch blocks, show user-friendly error messages with `sonner` toast
- Backend: Throw appropriate NestJS exceptions, let exception filters handle responses
- API errors: Return consistent error format from backend
- Validation: Use DTOs with class-validator decorators (backend)

## Performance

- React: Use `React.memo()` for expensive components, `useMemo()`/`useCallback()` when needed
- Code splitting: Lazy load routes with `React.lazy()` if needed
- Images: Use proper sizing and lazy loading
- Avoid unnecessary re-renders: Check dependencies in hooks

## Documentation References

- **Branch strategy**: `docs/git-strategy.md` - Git workflow and branch naming
- **Scripts guide**: `docs/SCRIPTS.md` - All utility scripts usage and examples
- **Database setup**: `docs/DATABASE.md` - Database configuration and connection guide
- **Security guide**: `docs/SECURITY.md` - Security best practices and SSH key management
- **Architecture**: `docs/architecture.md` - Project structure and design patterns

When suggesting script usage or database operations, reference the appropriate documentation file.
