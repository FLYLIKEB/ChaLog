## Git Workflow

- Before commit/push: Check `docs/git-strategy.md` (branch naming, merge procedures)
- When modifying screens/routes: Check `docs/architecture.md` and update if needed
- Pre-commit checks: `npm test`, `npm run lint`, `tsc --noEmit`
- Commit messages: Write in Korean (e.g., `feat: 노트 필터 기능 추가`, `fix: 인증 버그 수정`)

## Release Automation

- Full release: `scripts/full-release.sh "<commit-msg>" "<version-tag>" [feature/branch]`
  - Example: `scripts/full-release.sh "feat: add note filters" v0.5.0`
  - Process: test/lint → feature push → develop merge → release creation → main merge+tag → develop re-merge

## Quick Commit & Push ("ch" command)

When user types "ch" or "커밋", automatically execute:

1. Branch management: Check current branch → if `main`/`develop`, create `feature/*` branch based on changes
2. Change analysis: `git status` → group by feature (auth, notes, teas, components, config, etc.)
3. Feature-based commits: Stage each group → auto-generate Korean commit message (`feat:`, `fix:`, `refactor:`, etc.) → commit
4. Push & summary: After all commits, push → provide branch/commit summary

## Quick Pull ("pl" command)

When user types "pl" or "풀", automatically execute:

1. Remote update: `git fetch --all --prune`
2. Current branch pull: `git pull origin <current-branch>`
3. Main branches pull: Update `main`, `develop` (checkout → pull → return)
4. Summary: Provide updated branches and changes summary

## Code Style & Patterns

### Frontend (React + TypeScript)
- Use functional components with hooks, avoid class components
- Use `cn()` utility from `components/ui/utils.ts` for className merging
- Follow shadcn/ui component patterns: use Radix UI primitives + CVA for variants
- Import paths: Use `@/` alias for `src/` directory (e.g., `@/components/Button`)
- Component structure: Props interface → component → export default
- Use TypeScript strict types, avoid `any` unless necessary
- Prefer named exports for utilities, default exports for components

### Backend (NestJS)
- Use dependency injection with `@Injectable()` decorator
- Follow NestJS module pattern: Controller → Service → Entity
- Use DTOs for request/response validation
- Error handling: Use NestJS built-in exceptions (`NotFoundException`, `ForbiddenException`, etc.)
- Service methods should be async and return Promises
- Use TypeORM repositories with `@InjectRepository()` decorator

### File Structure
- Components: `src/components/` (UI components in `components/ui/`)
- Pages: `src/pages/` (route components)
- Backend modules: `backend/src/{module}/` (controller, service, entities, dto)
- Shared types: `packages/types/` (use in both frontend and backend)
- Utils: `src/lib/` (frontend), `backend/src/common/` (backend)

## Component Guidelines

- UI components: Use shadcn/ui components from `components/ui/` as base
- Custom components: Create in `components/` with descriptive names (PascalCase)
- Props: Define TypeScript interfaces above component
- Styling: Use Tailwind CSS classes, prefer utility classes over custom CSS
- Accessibility: Include proper ARIA labels and keyboard navigation
- Icons: Use `lucide-react` icons, import individually

## Type Definitions

- Shared types: Define in `packages/types/index.ts` for frontend/backend sharing
- Component props: Define inline or in same file
- API types: Match backend DTOs in `packages/types/`
- Use TypeScript utility types (`Pick`, `Omit`, `Partial`) when appropriate

## Testing

- Frontend: Use Vitest + Testing Library, tests in `__tests__/` directories
- Backend: Use Jest, tests alongside source files (`.spec.ts`)
- Test naming: `*.test.tsx` (frontend), `*.spec.ts` (backend)
- Mock data: Use `src/lib/mockData.ts` for frontend tests
- Test structure: Arrange → Act → Assert pattern

## Error Handling

- Frontend: Use try-catch blocks, show user-friendly error messages with `sonner` toast
- Backend: Throw appropriate NestJS exceptions, let exception filters handle responses
- API errors: Return consistent error format from backend
- Validation: Use DTOs with class-validator decorators (backend)

## Performance

- React: Use `React.memo()` for expensive components, `useMemo()`/`useCallback()` when needed
- Code splitting: Lazy load routes with `React.lazy()` if needed
- Images: Use proper sizing and lazy loading
- Avoid unnecessary re-renders: Check dependencies in hooks

Note: Branch strategy reference: `docs/git-strategy.md`
