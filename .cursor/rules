## Git Workflow

- Before commit/push: Check `docs/git-strategy.md` (branch naming, merge procedures)
- When modifying screens/routes: Check `docs/architecture.md` and update if needed
- Pre-commit checks: `npm test`, `npm run lint` (if exists), `tsc --noEmit`
- Commit messages: Write in Korean (e.g., `feat: 노트 필터 기능 추가`, `fix: 인증 버그 수정`)

## PR Review Process

When PR review requests are received, follow this procedure:

1. **List all reviews**: Use `gh api graphql` to check unresolved review threads
2. **Apply reviews one by one**: 
   - Review the content and modify code accordingly
   - Commit changes (one commit per review)
   - Resolve the review thread using GitHub API (`gh api graphql` mutation)
3. **After all reviews are applied**: Push to remote once (`git push`)

**Important**: Commit and resolve immediately after applying each review. Only push after all reviews are resolved.

## Documentation Updates

When making code changes, you MUST automatically update relevant markdown files:

- **README.md**: Update when adding new features, changing project structure, updating dependencies, or modifying setup instructions
- **docs/architecture.md**: Update when modifying routes/pages, component structure, data flow, or architectural patterns
- **docs/git-strategy.md**: Update when changing Git workflow or branch strategy
- **Backend README** (`backend/README.md`): Update when modifying backend structure, API endpoints, or setup

**Update triggers:**
- New features → README.md (main features section), architecture.md (relevant section)
- API changes → README.md (data & external integrations), architecture.md (API section)
- Component changes → architecture.md (component structure)
- Route/page changes → architecture.md (route section), README.md (folder structure)
- Dependency changes → README.md (NPM scripts, environment variables)
- File structure changes → README.md (folder structure highlights)
- Backend module changes → backend/README.md, architecture.md

**Update process:**
1. Analyze code changes to identify what documentation needs updating
2. Check relevant markdown files for sections that need updates
3. Update documentation to reflect code changes accurately
4. Ensure documentation examples match current code structure
5. Include code changes in the same commit when possible

## Release Automation

- Full release: `scripts/full-release.sh "<commit-msg>" "<version-tag>" [feature/branch]`
  - Example: `scripts/full-release.sh "feat: add note filters" v0.5.0`
  - Process: test/lint → feature push → main merge+tag
  - **Before execution**: Check if script exists at `scripts/full-release.sh`, if not, provide manual steps

## Utility Scripts

### Git Workflow Scripts

- **Quick commit**: `scripts/quick-commit.sh [branch] [message]`
  - Auto-commit and push changes
  - Example: `scripts/quick-commit.sh feature/new-feature "feat: 새로운 기능 추가"`
  - **Before execution**: Check if script exists, if not, execute manual git commands
  - See `docs/SCRIPTS.md` for details

- **Full release**: `scripts/full-release.sh "<commit-msg>" "<version-tag>" [feature-branch]`
  - Complete release automation (test → merge → tag → deploy)
  - Example: `scripts/full-release.sh "Release v1.2.3" "v1.2.3" feature/new-feature`
  - **Before execution**: Check if script exists, verify feature branch follows `feature/*` pattern
  - See `docs/SCRIPTS.md` for details

### Database Management Scripts

- **Start SSH tunnel**: `cd backend && ./scripts/start-ssh-tunnel.sh`
  - Start SSH tunnel for RDS connection via EC2
  - Requires `.env` file with SSH configuration
  - **Before execution**: Check if script exists, verify `.env` file exists
  - See `docs/DATABASE.md` and `docs/SCRIPTS.md` for details

- **Stop SSH tunnel**: `cd backend && ./scripts/stop-ssh-tunnel.sh`
  - Stop running SSH tunnel
  - **Before execution**: Check if SSH tunnel process is running

- **Check database**: `cd backend && ./scripts/check-database.sh`
  - Verify database connection and create database if needed
  - Requires SSH tunnel to be running
  - **Before execution**: Verify SSH tunnel is active

**Script usage workflow:**
1. Before development: `cd backend && ./scripts/start-ssh-tunnel.sh`
2. Verify connection: `cd backend && ./scripts/check-database.sh`
3. Start backend: `cd backend && npm run start:dev`
4. After development: `cd backend && ./scripts/stop-ssh-tunnel.sh`

**Migration Scripts:**
- **One-time migration scripts**: Scripts that perform database schema migrations
- **After successful execution**: MUST delete the migration script file
- **Rationale**: Migration scripts are one-time operations, keeping them can cause confusion and accidental re-execution
- **Example**: After running `migrate-to-auth-separation.js` successfully, delete the file immediately

**Temporary Documentation Files:**
- **Test guides and setup guides**: Documentation files created for temporary reference (e.g., `TESTING_*.md`, `*_SETUP.md`, `*_GUIDE.md`)
- **Workflow**: These files are already ignored by `.gitignore` (lines 3-6) and won't be committed. Delete them when no longer needed.
- **Rationale**: These are temporary reference documents for implementation, not permanent project documentation
- **Examples**: 
  - `docs/TESTING_KAKAO_LOGIN.md` - Delete after testing is complete
  - `docs/KAKAO_DEVELOPER_SETUP.md` - Delete after setup is complete
  - `docs/USER_TABLE_DESIGN_PATTERNS.md` - Can be kept if it's permanent reference, otherwise delete

For detailed script documentation, see `docs/SCRIPTS.md`

## Quick Commit & Push

When user requests to commit changes, push changes, or says "커밋해줘", "커밋하고 푸시해줘", execute the following:

**Prerequisites:**
1. Check current branch: `git branch --show-current`
2. Check for uncommitted changes: `git status --porcelain`
3. If no changes exist, inform user and stop

**Execution steps:**
1. **Branch management**: 
   - If current branch is `main`, analyze changes to determine feature name
   - Create `feature/*` branch based on changed files (e.g., `feature/auth-login`, `feature/note-filter`)
   - Branch naming: Use changed directory names or file prefixes (auth, notes, teas, components, config, etc.)
   
2. **Change analysis**: 
   - Run `git status` to get all changed files
   - Group changes by feature/module:
     - `src/auth/`, `backend/src/auth/` → auth
     - `src/pages/Note*`, `src/components/Note*` → notes
     - `src/pages/Tea*`, `src/components/Tea*` → teas
     - `src/components/` → components
     - `package.json`, `vite.config.ts`, etc. → config
     - `docs/` → docs
   
3. **Documentation check**: 
   - Analyze changes → identify which markdown files need updates (README.md, docs/architecture.md, etc.)
   - Update documentation files if needed before committing
   
4. **Pre-commit validation** (MUST execute before any commit):
   - Check if `npm run lint` exists in package.json → run if exists, skip if not
   - Run `tsc --noEmit` (TypeScript project)
   - Check if `npm run test:run` exists → run if exists, skip if not
   - If any check fails, STOP and show error message to user
   - Only proceed if all checks pass
   
5. **Feature-based commits**: 
   - For each group: stage files → auto-generate Korean commit message
   - Commit message format: `<type>: <description>` (e.g., `feat: 인증 로그인 기능 추가`, `fix: 노트 필터 버그 수정`)
   - Commit types: `feat:`, `fix:`, `refactor:`, `docs:`, `test:`, `chore:`, `style:`
   - Commit each group separately
   
6. **Push & summary**: 
   - After all commits, push current branch: `git push origin <branch-name>`
   - If branch doesn't exist on remote, use: `git push -u origin <branch-name>`
   - Provide summary: branch name, commit count, commit messages

**Alternative:** If `scripts/quick-commit.sh` exists, you can suggest using it:
```bash
./scripts/quick-commit.sh [branch] [message]
```

## Quick Pull

When user requests to pull updates, sync branches, or says "풀 받아줘", "업데이트해줘", execute the following:

**Prerequisites:**
1. Check current branch: `git branch --show-current`
2. Check for uncommitted changes: `git status --porcelain`
3. If uncommitted changes exist, warn user and ask for confirmation

**Execution steps:**
1. **Remote update**: `git fetch --all --prune`
2. **Current branch pull**: 
   - `git pull origin <current-branch>`
   - If conflicts occur, STOP and inform user
3. **Main branch pull**: 
   - Save current branch name
   - `git checkout main`
   - `git pull origin main`
   - Return to original branch: `git checkout <saved-branch>`
4. **Summary**: Provide updated branches and changes summary

## Merge Main to All Branches

When user requests to merge main to branches, sync branches, or says "메인 머지해줘", execute the following:

**Prerequisites:**
1. Check current branch: `git branch --show-current`
2. Ensure `main` branch is up to date: `git checkout main && git pull origin main`
3. Get list of local branches: `git branch --list | grep -v main | xargs`

**Execution steps:**
1. **Save current branch**: Store current branch name
2. **Update main**: `git checkout main && git pull origin main`
3. **Get all local branches**: `git branch --list | grep -v "main\|^\*" | sed 's/^[ ]*//'`
4. **For each branch**:
   - `git checkout <branch-name>`
   - `git merge main --no-edit`
   - If conflicts occur: Skip this branch, log conflict, continue to next
   - If merge succeeds: Push to remote
     - Check if branch diverged: `git status` → if diverged, use `git push --force-with-lease origin <branch-name>`
     - Otherwise: `git push origin <branch-name>`
5. **Return to original branch**: `git checkout <saved-branch>`
6. **Summary**: Provide list of successfully merged branches and any conflicts

## Clean Remote Branches

When user requests to clean branches, remove old branches, or says "브랜치 정리해줘", execute the following:

**Prerequisites:**
1. Fetch latest remote state: `git fetch --all --prune`

**Execution steps:**
1. **Fetch and prune**: `git fetch --all --prune`
2. **Find gone branches**: 
   - List local branches tracking remote branches that no longer exist
   - Command: `git branch -vv | grep ': gone]' | awk '{print $1}'`
3. **Show list to user**: Display branches that will be deleted
4. **Delete branches**: 
   - For each branch: `git branch -D <branch-name>`
   - If deletion fails (e.g., unmerged changes), skip and inform user
5. **Summary**: Provide list of deleted branches

## Pre-commit Validation

**MANDATORY**: Before executing ANY commit command, you MUST run these checks:

1. **Check for uncommitted changes**: `git status --porcelain` → if empty, stop
2. **Lint check**: 
   - Check if `npm run lint` exists in root `package.json`
   - If exists: Run `npm run lint`
   - If fails: STOP, show errors, do NOT commit
3. **Type check**: 
   - Run `tsc --noEmit` (TypeScript project)
   - If fails: STOP, show errors, do NOT commit
4. **Test run**: 
   - Check if `npm run test:run` exists in root `package.json`
   - If exists: Run `npm run test:run`
   - If fails: STOP, show errors, do NOT commit
5. **Only proceed with commit if all checks pass**

**Error handling:**
- If any check fails, show specific error messages
- Do NOT proceed with commit
- Suggest fixes to user
- Allow user to skip validation only if explicitly requested

**Note:** The `scripts/quick-commit.sh` script includes pre-commit validation automatically if it exists.

## Create Pull Request

When user requests to create PR, open PR, or says "PR 생성해줘", "풀리퀘스트 만들어줘", execute the following:

**Prerequisites:**
1. Check current branch: `git branch --show-current`
2. Verify branch follows `feature/*` pattern
3. If not a feature branch, inform user and stop

**Execution steps:**
1. **Check current branch**: 
   - Must be a feature branch (`feature/*`)
   - If not, inform user and stop
   
2. **Ensure branch is pushed**: 
   - Check if branch exists on remote: `git ls-remote --heads origin <branch-name>`
   - If not pushed: `git push -u origin <branch-name>`
   - If already pushed but has local commits: `git push origin <branch-name>`
   
3. **Generate PR title**: 
   - Based on branch name (remove `feature/` prefix)
   - Capitalize and format: e.g., `feature/note-filter` → "Note Filter 기능 추가"
   
4. **Generate PR description**: 
   - Get recent commits: `git log main..HEAD --oneline`
   - Summarize commits, changed files, and affected modules
   - Format as markdown
   
5. **Create PR**: 
   - Check if GitHub CLI (`gh`) is available: `gh --version`
   - If available: `gh pr create --title "<title>" --body "<description>"`
   - If not available: Provide manual instructions with GitHub URL
   - URL format: `https://github.com/<owner>/<repo>/compare/main...<branch-name>?expand=1`
   
6. **Summary**: Provide PR URL and details

## Error Handling & Edge Cases

### Git Conflicts
- **During merge**: Stop execution, show conflict files, ask user to resolve
- **During pull**: Stop execution, show conflict files, ask user to resolve
- **Never force merge or pull** without user confirmation

### Validation Failures
- **Lint errors**: Show specific file and line errors, suggest fixes
- **Type errors**: Show TypeScript errors, suggest fixes
- **Test failures**: Show failing tests, suggest fixes
- **Never skip validation** unless user explicitly requests

### Missing Scripts
- **Script not found**: Check if script exists before execution
- **If missing**: Provide manual alternative steps
- **Never assume scripts exist**

### Branch Issues
- **Branch doesn't exist**: Create it before operations
- **Branch diverged**: Use `--force-with-lease` only after user confirmation
- **Cannot delete branch**: Inform user why (unmerged changes, current branch, etc.)

### Network Issues
- **Push fails**: Retry once, if fails inform user
- **Pull fails**: Check network, inform user
- **Remote not found**: Inform user to check remote configuration

## Code Style & Patterns

### Frontend (React + TypeScript)
- Use functional components with hooks, avoid class components
- Use `cn()` utility from `components/ui/utils.ts` for className merging
- Follow shadcn/ui component patterns: use Radix UI primitives + CVA for variants
- Import paths: Use `@/` alias for `src/` directory (e.g., `@/components/Button`)
- Component structure: Props interface → component → export default
- Use TypeScript strict types, avoid `any` unless necessary
- Prefer named exports for utilities, default exports for components

### Backend (NestJS)
- Use dependency injection with `@Injectable()` decorator
- Follow NestJS module pattern: Controller → Service → Entity
- Use DTOs for request/response validation
- Error handling: Use NestJS built-in exceptions (`NotFoundException`, `ForbiddenException`, etc.)
- Service methods should be async and return Promises
- Use TypeORM repositories with `@InjectRepository()` decorator

### File Structure
- Components: `src/components/` (UI components in `components/ui/`)
- Pages: `src/pages/` (route components)
- Backend modules: `backend/src/{module}/` (controller, service, entities, dto)
- Shared types: `packages/types/` (use in both frontend and backend)
- Utils: `src/lib/` (frontend), `backend/src/common/` (backend)

## Component Guidelines

- UI components: Use shadcn/ui components from `components/ui/` as base
- Custom components: Create in `components/` with descriptive names (PascalCase)
- Props: Define TypeScript interfaces above component
- Styling: Use Tailwind CSS classes, prefer utility classes over custom CSS
- Accessibility: Include proper ARIA labels and keyboard navigation
- Icons: Use `lucide-react` icons, import individually

## Type Definitions

- Shared types: Define in `packages/types/index.ts` for frontend/backend sharing
- Component props: Define inline or in same file
- API types: Match backend DTOs in `packages/types/`
- Use TypeScript utility types (`Pick`, `Omit`, `Partial`) when appropriate

## Testing

- Frontend: Use Vitest + Testing Library, tests in `__tests__/` directories
- Backend: Use Jest, tests alongside source files (`.spec.ts`)
- Test naming: `*.test.tsx` (frontend), `*.spec.ts` (backend)
- Mock data: Use `src/lib/mockData.ts` for frontend tests (if exists)
- Test structure: Arrange → Act → Assert pattern

## Error Handling

- Frontend: Use try-catch blocks, show user-friendly error messages with `sonner` toast
- Backend: Throw appropriate NestJS exceptions, let exception filters handle responses
- API errors: Return consistent error format from backend
- Validation: Use DTOs with class-validator decorators (backend)

## Performance

- React: Use `React.memo()` for expensive components, `useMemo()`/`useCallback()` when needed
- Code splitting: Lazy load routes with `React.lazy()` if needed
- Images: Use proper sizing and lazy loading
- Avoid unnecessary re-renders: Check dependencies in hooks

## Documentation References

- **Branch strategy**: `docs/git-strategy.md` - Git workflow and branch naming
- **Scripts guide**: `docs/SCRIPTS.md` - All utility scripts usage and examples
- **Database setup**: `docs/DATABASE.md` - Database configuration and connection guide
- **Security guide**: `docs/SECURITY.md` - Security best practices and SSH key management
- **Architecture**: `docs/architecture.md` - Project structure and design patterns

When suggesting script usage or database operations, reference the appropriate documentation file.
